# Learning From Our Elders
## Rob Napier

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.50.55.png)

^ Разбиваем логику на маленькие части каждая выполняет одну обязанность (Single Responsibility)
^ Профит не только в возможности реюза, маленькие юниты проще понимать и изменять

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.11.51.png)

^ композиция - ключ к решению (про паттерны)
^ берем класс, выделяем из него отдельные классы с определенными ответственностями

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.12.09.png)

^ некоторые понимают композицию так )
^ это противоположность композиции. Протоколы, которые специально были выделены для разнесения обязанностей тут смешиваются в один объект

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.13.07.png)

^ рассмотрим пример, таблица с ячейками
^ разная логика при залогиненом юзере и нет

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.13.37.png)

^ добавили поиск )
^ много ифов - много багов

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.14.49.png)

^ решение - вынесение датасорсов в отдельные объекты, разные ответственности

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.15.04.png)

^ if никуда не делся
^ теперь if только в одном месте

---

![inline, Fit, original](3/Screen Shot 2017-05-28 at 22.16.19.png) ![inline, Fit, original](3/Screen Shot 2017-05-28 at 22.18.15.png)

^ Еще один пример улучшений
^ Например у Label моделью является String, контроллер не знает как там Label отрисовывается, просто пихает стрингу туда
^ То же самое можно применить например к ячейкам, пусть ячейка сама решает как ее конфигурировать, при изменении ячейки не нужно переписывать контроллер

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.19.43.png)

^ задача - есть 2 массива, нужно отсортировать по возрасту

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 23.25.37.png)

^ EASY одно из решений на StackOverflow: объединить в массивы по парам, отсортировать массивы
^ можно написать тесты на это

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.21.14.png)

^ Simple решение - поместить в структуру и сортировать уже там

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 23.29.29.png)

^ тип может иметь диапазон значений, операций над типом
^ в нашем кейсе не всегда нужен весь диапазон. пример - состояние вьюхи (Int) : загрузка, ошибка, загружено. 3 значения, но Int имеет больший диапазон

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.33.37.png)

^ другой пример, ID юзера - Int ID не имеет смысла складывать, умножать, но c Int это можно делать. Нужно выделять отдельный тип

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.25.29.png)

^ строже типы - меньше тестов, дальше примеры

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.29.12.png)

^ Следует избегать использования нестрогих типов (AnyObject, Dictionary) почти везде можно использовать струтруры

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.30.39.png)

^ пример когда нужен выбор

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.37.46.png)

^ пример запрос на сервер с
^ не понятно что за стринги и в каких сочетаниех это все имеет смысл

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.39.08.png)

^ структуры подходят когда нам нужна логика "И" (имя и адрес)

^ все еще не понятно что будет если Person и Error nil или оба имеют ненудевое значение

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.40.22.png)

^ энамы подходят когда нужна логика "ИЛИ"

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.41.07.png)

^ итоговый вариант

---

![100% , Center, original](3/Screen Shot 2017-05-28 at 22.41.31.png)
